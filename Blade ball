import asyncio
import random
import time
import aiohttp
from typing import List, Dict
from threading import Thread
from message_manager import MessageManager
from auth_system import Authorize, GuildJoiner
import requests

class AutoTrader:
    def __init__(self, config: Dict):
        self.config = config
        self.message_manager = MessageManager()
        self.running = False
        self.active_tasks = {}
        
    def load_tokens(self) -> List[str]:
        """Load trader tokens from file"""
        try:
            with open('tokens_trade.txt', 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            return []
    
    def get_token_session(self, token_line: str):
        """Create authenticated session for token with shared proxy"""
        try:
            # Extract token
            if ':' in token_line:
                parts = token_line.split(':')
                if len(parts) >= 3:
                    token = parts[2].strip()
                else:
                    token = token_line.strip()
            else:
                token = token_line.strip()
            
            # Create authorized session WITH PROXY
            auth = Authorize(
                self.config["client_id"],
                self.config["redirect_uri"],
                self.config["client_secret"],
                token_line  # Pass the full token line for proxy assignment
            )
            
            result = auth.authorize()
            if not result:
                return None
            
            user_id, access_token, refresh_token, discord_token = result
            
            # Create session (proxy is already handled by the auth system)
            session = requests.Session()
            
            return {
                "token": discord_token,
                "access_token": access_token,
                "user_id": user_id,
                "session": session
            }
            
        except Exception as e:
            print(f"âŒ Failed to auth token: {e}")
            return None
    
    async def send_trade_message_with_template(self, session_data: Dict, channel_id: str, key_id: str, key_manager, message: str):
        """Send a trade message using a specific message"""
        try:
            headers = {
                "Authorization": session_data["token"],
                "Content-Type": "application/json"
            }
            
            payload = {
                "content": message,
                "tts": False
            }
            
            url = f"https://discord.com/api/v9/channels/{channel_id}/messages"
            
            async with aiohttp.ClientSession() as http_session:
                async with http_session.post(url, json=payload, headers=headers) as response:
                    if response.status in (200, 201, 204):
                        print(f"âœ… Trade message sent to channel {channel_id}")
                        key_manager.increment_messages(key_id)
                        return True
                    else:
                        print(f"âŒ Failed to send trade message: {response.status}")
                        return False
                            
        except Exception as e:
            print(f"âŒ Error sending trade message: {e}")
            return False
    
    def start_trading(self, key_id: str, channel_id: str, delay: int, key_manager, category: str = "general"):
        """Start auto-trading for a key with specified category"""
        if key_id in self.active_tasks:
            print(f"âš ï¸ Trading already running for key {key_id}")
            return
        
        # Update category setting
        key_manager.update_settings(key_id, {"category": category})
        
        # Get how many tokens this key should use
        key_data = key_manager.keys_db.get(key_id, {})
        max_tokens = key_data.get("tokens", 0)
        
        self.running = True
        self.active_tasks[key_id] = {
            "running": True,
            "task": None,
            "current_message": None,
            "message_count": 0,
            "max_message_repeat": random.randint(10, 30),
            "category": category
        }
        
        async def trading_loop_with_category():
            tokens = self.load_tokens()
            if not tokens:
                print("âŒ No trader tokens available")
                return
            
            usable_tokens = tokens[:max_tokens]
            print(f"âœ… Using {len(usable_tokens)}/{max_tokens} tokens for key {key_id} with category: {category}")
            
            if not usable_tokens:
                print("âŒ No usable tokens")
                return
            
            # Authorize only the tokens we'll use
            sessions = []
            for token_line in usable_tokens:
                session = self.get_token_session(token_line)
                if session:
                    sessions.append(session)
            
            if not sessions:
                print("âŒ No valid trader tokens")
                return
            
            print(f"âœ… Starting auto-trader with {len(sessions)} tokens, category: {category}")
            
            token_index = 0
            messages_sent = 0
            current_message = None
            message_repeat_count = 0
            repeat_target = random.randint(7, 20)  # 7-20 times before switching
            
            # Run continuously until manually stopped
            while self.active_tasks.get(key_id, {}).get("running", False):
                
                # Get current session
                session = sessions[token_index % len(sessions)]
                token_index += 1
                
                # Get new message if we've repeated enough or don't have one
                if current_message is None or message_repeat_count >= repeat_target:
                    current_message = self.message_manager.get_random_message("trade", category)
                    message_repeat_count = 0
                    repeat_target = random.randint(7, 20)  # New random repeat count
                    print(f"ğŸ”„ Switching to new {category} message (will repeat {repeat_target} times)")
                
                success = await self.send_trade_message_with_template(session, channel_id, key_id, key_manager, current_message)
                
                if success:
                    messages_sent += 1
                    message_repeat_count += 1
                    print(f"ğŸ“¤ Sent {messages_sent} trades (Message #{message_repeat_count}/{repeat_target})")
                    # Update message count periodically (every 10 messages)
                    if messages_sent % 10 == 0:
                        key_manager.increment_messages(key_id)
                
                await asyncio.sleep(delay)
            
            self.stop_trading(key_id)
            print(f"âœ… Auto-trader stopped for key {key_id}")
        
        # Start the trading loop in background
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        self.active_tasks[key_id]["task"] = loop.create_task(trading_loop_with_category())
        
        def run_loop():
            asyncio.set_event_loop(loop)
            loop.run_forever()
        
        thread = Thread(target=run_loop, daemon=True)
        thread.start()
    
    def stop_trading(self, key_id: str):
        """Stop auto-trading for a key"""
        if key_id in self.active_tasks:
            print(f"â¹ï¸ Stopping trader for key {key_id}")
            self.active_tasks[key_id]["running"] = False
            
            task = self.active_tasks[key_id].get("task")
            if task:
                task.cancel()
            
            # IMPORTANT: Wait a bit before deleting to let loop finish
            time.sleep(0.5)
            del self.active_tasks[key_id]
            print(f"âœ… Auto-trader stopped for key {key_id}")