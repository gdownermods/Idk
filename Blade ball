import random
import time
import json
import os
from typing import List, Dict
from datetime import datetime

class MessageManager:
    def __init__(self):
        self.base_path = "messages"
        self.user_lists_file = "vouch_users.json"  # Store user lists per key
        self.message_history = {}  # Track recent messages to avoid repeats
        
        # Create default message directories if they don't exist
        self.create_default_directories()
    
    def create_default_directories(self):
        """Create default message directories if they don't exist"""
        directories = [
            "trade/general",
            "trade/sab", 
            "trade/adoptme",
            "trade/mix",
            "vouch/general",
            "vouch/sab",
            "vouch/adoptme",
            "vouch/mix"
        ]
        
        for directory in directories:
            os.makedirs(os.path.join(self.base_path, directory), exist_ok=True)
            
            # Create sample message files if empty
            file_path = os.path.join(self.base_path, directory, "messages.txt")
            if not os.path.exists(file_path) or os.path.getsize(file_path) == 0:
                self.create_sample_messages(directory)
    
    def create_sample_messages(self, directory: str):
        """Create sample messages for a directory"""
        category, subcategory = directory.split("/")
        
        if category == "trade":
            if subcategory == "sab":
                messages = ["Trading SAB items!", "WTT SAB gears", "SAB trading available"]
            elif subcategory == "adoptme":
                messages = ["Adopt Me trading", "Trading Adopt Me pets", "WTT Adopt Me items"]
            elif subcategory == "mix":
                messages = ["Mixed trading available", "Various items for trade", "Trading multiple games"]
            else:  # general
                messages = ["WTS OSRS Gold", "WTB RS3 GP", "Trading now!"]
        else:  # vouch
            if subcategory == "sab":
                messages = ["Vouch for {user}! Great SAB trader", "{user} trusted for SAB trades"]
            elif subcategory == "adoptme":
                messages = ["Vouch for {user}! Legit Adopt Me trader", "{user} trusted for Adopt Me"]
            elif subcategory == "mix":
                messages = ["Vouch for {user}! Various trades", "{user} trusted for multiple games"]
            else:  # general
                messages = ["Vouch for {user}! Smooth trade", "{user} is trusted"]
        
        file_path = os.path.join(self.base_path, directory, "messages.txt")
        with open(file_path, 'w', encoding='utf-8') as f:
            for msg in messages:
                f.write(msg + "\n")
    
    def get_random_message(self, category: str, subcategory: str = "general"):
        """Get random message from specified category and subcategory"""
        try:
            # Build the file path
            file_path = os.path.join(self.base_path, category, subcategory, "messages.txt")
            
            # If subcategory doesn't exist, fallback to general
            if not os.path.exists(file_path):
                file_path = os.path.join(self.base_path, category, "general", "messages.txt")
            
            # If still doesn't exist, create it
            if not os.path.exists(file_path):
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                self.create_sample_messages(f"{category}/{subcategory}")
            
            # Load messages
            with open(file_path, 'r', encoding='utf-8') as f:
                messages = [line.strip() for line in f if line.strip()]
            
            if not messages:
                # Create default message
                default_msg = f"Default {subcategory} {category} message"
                messages = [default_msg]
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(default_msg + "\n")
            
            # Filter out recently used messages (last 5)
            key = f"{category}_{subcategory}"
            recent = self.message_history.get(key, [])
            available = [msg for msg in messages if msg not in recent[-5:]]
            
            # If all messages recently used, use any
            if not available:
                available = messages
            
            # Select random message
            selected = random.choice(available)
            
            # Update history
            if key not in self.message_history:
                self.message_history[key] = []
            
            self.message_history[key].append(selected)
            if len(self.message_history[key]) > 10:
                self.message_history[key].pop(0)
            
            return selected
                
        except Exception as e:
            print(f"âŒ Error loading messages from {category}/{subcategory}: {e}")
            return f"Default {subcategory} {category} message"
    
    def get_available_categories(self, main_category: str):
        """Get available subcategories for a main category"""
        categories_path = os.path.join(self.base_path, main_category)
        if not os.path.exists(categories_path):
            return ["general"]
        
        categories = ["general"]  # Always include general
        for item in os.listdir(categories_path):
            item_path = os.path.join(categories_path, item)
            if os.path.isdir(item_path):
                categories.append(item)
        
        return list(set(categories))
    
    # KEEP ALL YOUR EXISTING USER MANAGEMENT METHODS:
    def load_user_list(self, key_id: str) -> List[str]:
        """Load user list for a specific key"""
        try:
            with open(self.user_lists_file, 'r') as f:
                data = json.load(f)
                return data.get(key_id, [])
        except FileNotFoundError:
            return []
    
    def save_user_list(self, key_id: str, users: List[str]):
        """Save user list for a specific key"""
        try:
            with open(self.user_lists_file, 'r') as f:
                data = json.load(f)
        except FileNotFoundError:
            data = {}
        
        data[key_id] = users
        
        with open(self.user_lists_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def add_users_to_list(self, key_id: str, users: List[str]):
        """Add users to existing list"""
        current = self.load_user_list(key_id)
        new_users = [u.strip() for u in users if u.strip() and u.strip() not in current]
        updated = current + new_users
        self.save_user_list(key_id, updated)
    
    def remove_users_from_list(self, key_id: str, users: List[str]):
        """Remove users from list"""
        current = self.load_user_list(key_id)
        users_to_remove = [u.strip() for u in users if u.strip()]
        updated = [u for u in current if u not in users_to_remove]
        self.save_user_list(key_id, updated)
    
    def get_next_user(self, key_id: str) -> str:
        """Get next user to vouch (round-robin)"""
        users = self.load_user_list(key_id)
        if not users:
            return "@user"  # Default placeholder
        
        # Get rotation state
        rotation_file = "user_rotation.json"
        try:
            with open(rotation_file, 'r') as f:
                rotation = json.load(f)
        except FileNotFoundError:
            rotation = {}
        
        current_index = rotation.get(key_id, 0)
        
        # Get user
        user = users[current_index % len(users)]
        
        # Update index for next time
        rotation[key_id] = current_index + 1
        with open(rotation_file, 'w') as f:
            json.dump(rotation, f, indent=2)
        
        return user