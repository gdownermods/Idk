import asyncio
import random
import time
import aiohttp
from typing import List, Dict
from threading import Thread
from message_manager import MessageManager
from auth_system import Authorize, GuildJoiner
import requests
import re
import json
import os

class AutoVoucher:
    def __init__(self, config: Dict):
        self.config = config
        self.message_manager = MessageManager()
        self.running = False
        self.active_tasks = {}
        
    def load_tokens(self) -> List[str]:
        """Load voucher tokens from file"""
        try:
            with open('tokens_vouch.txt', 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            return []
    
    def get_token_session(self, token_line: str):
        """Create authenticated session for token with shared proxy"""
        try:
            # Extract token
            if ':' in token_line:
                parts = token_line.split(':')
                if len(parts) >= 3:
                    token = parts[2].strip()
                else:
                    token = token_line.strip()
            else:
                token = token_line.strip()
            
            # Create authorized session WITH PROXY
            auth = Authorize(
                self.config["client_id"],
                self.config["redirect_uri"],
                self.config["client_secret"],
                token_line  # Pass the full token line for proxy assignment
            )
            
            result = auth.authorize()
            if not result:
                return None
            
            user_id, access_token, refresh_token, discord_token = result
            
            # Create session
            session = requests.Session()
            
            return {
                "token": discord_token,
                "access_token": access_token,
                "user_id": user_id,
                "session": session
            }
            
        except Exception as e:
            print(f"‚ùå Failed to auth token: {e}")
            return None
    
    def validate_discord_message(self, message: str) -> bool:
        """Check if a message is valid for Discord"""
        if not message or len(message.strip()) == 0:
            return False
        
        if len(message) > 2000:
            print(f"‚ö†Ô∏è Message too long: {len(message)} chars")
            return False
        
        # Check for any obvious issues
        if "@everyone" in message or "@here" in message:
            print("‚ö†Ô∏è Message contains @everyone or @here")
            return False
        
        return True
    
    def get_user_rotation_state(self, key_id: str) -> Dict:
        """Get current rotation state for users"""
        rotation_file = f"user_rotation_{key_id}.json"
        try:
            if os.path.exists(rotation_file):
                with open(rotation_file, 'r') as f:
                    return json.load(f)
        except:
            pass
        
        return {"current_index": 0}
    
    def update_user_rotation(self, key_id: str, new_index: int):
        """Update rotation index for users"""
        rotation_file = f"user_rotation_{key_id}.json"
        state = {"current_index": new_index}
        try:
            with open(rotation_file, 'w') as f:
                json.dump(state, f)
        except:
            pass
    
    async def send_vouch_message_with_template(self, session_data: Dict, channel_id: str, key_id: str, key_manager, message_template: str, category: str = "general"):
        """Send a vouch message using a specific template with user rotation"""
        try:
            # Get all users for this key
            all_users = self.message_manager.load_user_list(key_id)
            if not all_users:
                print(f"‚ö†Ô∏è No users configured for key {key_id}")
                return False
            
            # Get rotation state
            rotation_state = self.get_user_rotation_state(key_id)
            user_index = rotation_state.get("current_index", 0)
            
            # Get next user in rotation
            target_user = all_users[user_index % len(all_users)]
            
            # Update rotation for next time
            self.update_user_rotation(key_id, (user_index + 1) % len(all_users))
            
            # Format the user mention
            if target_user.isdigit() and len(target_user) >= 17:
                user_mention = f"<@{target_user}>"
            elif target_user.startswith("<@") and target_user.endswith(">"):
                user_mention = target_user
            else:
                user_mention = f"<@{target_user}>"
            
            # Find ALL user mentions in the template
            mention_pattern = r'<@!?\d{17,19}>'
            mentions = re.findall(mention_pattern, message_template)
            
            if mentions:
                # Replace the first mention in the template with our target user
                message = message_template
                for i, mention in enumerate(mentions):
                    if i == 0:
                        message = message.replace(mention, user_mention, 1)
            else:
                message = f"Vouch {user_mention}! {message_template}"
            
            # Validate message
            if not self.validate_discord_message(message):
                print(f"‚ùå Invalid message, skipping: {message[:50]}...")
                return False
            
            # Prepare request
            headers = {
                "Authorization": session_data["token"],
                "Content-Type": "application/json"
            }
            
            user_id = target_user.strip("<@!>")
            
            payload = {
                "content": message,
                "tts": False,
                "allowed_mentions": {
                    "users": [user_id] if user_id.isdigit() else []
                }
            }
            
            url = f"https://discord.com/api/v9/channels/{channel_id}/messages"
            
            async with aiohttp.ClientSession() as http_session:
                async with http_session.post(url, json=payload, headers=headers) as response:
                    response_text = await response.text()
                    
                    if response.status in (200, 201, 204):
                        print(f"‚úÖ Vouch message sent for {user_mention} ({user_index % len(all_users) + 1}/{len(all_users)})")
                        key_manager.increment_messages(key_id)
                        return True
                    else:
                        print(f"‚ùå Failed to send vouch message: {response.status}")
                        return False
                        
        except Exception as e:
            print(f"‚ùå Error sending vouch message: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def start_vouching(self, key_id: str, channel_id: str, delay: int, key_manager, category: str = "general"):
        """Start auto-vouching for a key with specified category"""
        print(f"DEBUG: Starting vouching for key {key_id}, channel {channel_id}, category: {category}")
        
        if key_id in self.active_tasks:
            print(f"‚ö†Ô∏è Vouching already running for key {key_id}")
            return
        
        # Check if channel ID is valid
        if not channel_id or not str(channel_id).isdigit():
            print(f"‚ùå Invalid channel ID: {channel_id}")
            return
        
        # Check if users list exists
        users = self.message_manager.load_user_list(key_id)
        if not users:
            print(f"‚ö†Ô∏è No users configured for key {key_id}")
            return
        
        # Update category setting
        key_manager.update_settings(key_id, {"category": category})
        
        # Get how many tokens this key should use
        key_data = key_manager.keys_db.get(key_id, {})
        max_tokens = key_data.get("tokens", 0)
        
        self.running = True
        self.active_tasks[key_id] = {
            "running": True,
            "task": None,
            "current_message": None,
            "message_count": 0,
            "max_message_repeat": random.randint(10, 30),
            "category": category
        }
        
        async def vouching_loop_with_category():
            tokens = self.load_tokens()
            if not tokens:
                print("‚ùå No voucher tokens available")
                return
            
            usable_tokens = tokens[:max_tokens]
            print(f"‚úÖ Using {len(usable_tokens)}/{max_tokens} tokens for key {key_id} with category: {category}")
            
            if not usable_tokens:
                print("‚ùå No usable tokens")
                return
            
            # Authorize only the tokens we'll use
            sessions = []
            for token_line in usable_tokens:
                session = self.get_token_session(token_line)
                if session:
                    sessions.append(session)
            
            if not sessions:
                print("‚ùå No valid voucher tokens")
                return
            
            users = self.message_manager.load_user_list(key_id)
            print(f"‚úÖ Starting auto-voucher with {len(sessions)} tokens for {len(users)} users, category: {category}")
            
            token_index = 0
            messages_sent = 0
            current_message = None
            message_repeat_count = 0
            max_repeat = random.randint(10, 30)
            
            while self.active_tasks.get(key_id, {}).get("running", False):
                
                # FIXED: Token rotation - each token gets different message
                session = sessions[token_index % len(sessions)]
                token_index += 1
                
                # Get NEW message for each token
                current_message = self.message_manager.get_random_message("vouch", category)
                print(f"üîÑ Token {token_index % len(sessions)} using new {category} message")
                
                success = await self.send_vouch_message_with_template(session, channel_id, key_id, key_manager, current_message, category)
                
                if success:
                    messages_sent += 1
                    print(f"üì§ Sent {messages_sent} vouches (Token #{token_index % len(sessions)})")
                    if messages_sent % 5 == 0:
                        key_manager.increment_messages(key_id)
                
                await asyncio.sleep(delay)
            
            self.stop_vouching(key_id)
            print(f"‚úÖ Auto-voucher stopped for key {key_id}")
        
        # Start the vouching loop in background
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        self.active_tasks[key_id]["task"] = loop.create_task(vouching_loop_with_category())
        
        def run_loop():
            asyncio.set_event_loop(loop)
            loop.run_forever()
        
        thread = Thread(target=run_loop, daemon=True)
        thread.start()
    
    def stop_vouching(self, key_id: str):
        """Stop auto-vouching for a key"""
        if key_id in self.active_tasks:
            self.active_tasks[key_id]["running"] = False
            task = self.active_tasks[key_id]["task"]
            if task:
                task.cancel()
            del self.active_tasks[key_id]
            print(f"‚èπÔ∏è Stopped auto-voucher for key {key_id}")